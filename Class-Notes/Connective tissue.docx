{-In order to deal with IO we need to know how to deal with side effects.
Even though Haskell wil avoid side effects we still need to know how to deal with it.
Popping off characters from the keyboard buffer is a state, a state that the keyboard has changed.
-}
-- we can make a function that will take in the user input and everytime we call it we won't know what we will get out of it
--inputDiff :: Int
--inputDiff = nextInt --there is no function that called nextInt
{-In Haskell we can look at a function and know exactly what hte function will return,
once we bring in input there will be uncertainty and won't know what will happen when we call a function.
there has not been a good solution to this problem for functional language.
IO in Haskell will define the idea of:
  actions happening in a sequence, this is how we will moedel the state of the world changing.-}
type IO = World -> World --when there is IO the state of the world will change
{-we want to write programs that will return a value-}
type IO a = World -> (a , World) --we will change the world state using the input 'a'
  IO Char -- the type of actions that return a character, some IO has occur and we will return a char instead
  IO () -- the type that say we are not in a fully functional state anymore we performed IO but not return any result
  --some basic actions that are defined in Haskell
getChar :: IO Char --this perform IO and then return a Char, kinda like Int and not the same as Maybe Int
putChar :: Char -> IO () --write a character to the terminal, takes a character as input and performs output and return IO actions IO () just means that actions has been performed
return :: a -> IO a --take some value of any datatype and this will return teh same value the same datatype but now in IO land, this is a bridge function to bridge normal datatype and IO
-- a -> IO a is possible but its a one way brdige and can't go back on that bridge, once we go from functional to non functional we can;t go back
getLine :: IO Strings --IO Strings == IO [Char] similar to putChar
putStr :: String -> IO () --similar to putChar but return strings
putStr [] = return () --this means it will turn () into IO (). () is a value that has no useful information.
putStr (x:xs) = do putChar x
                   putChar xs
putStrLn :: String -> IO () --similar to putStr but with auto \n at the end
putStrLn str = do putStr str
                  putStr "\n"

{-do sequence
sequence of IO actions into a single, composite one
general form: do  v1 <- a
                  v2 <-  a2
                  v3 <-  a3
                  v4 <-  a4
                    ..
                  vn <-  an
                  return (f v1 v2..vn) we can call some function f that will transform the result, the return line is optional for do sequence-}
example
act :: IO (Char, Char) --will return a 2 item tuple
act = do x <- getChar
         getChar -- toss the second letter and not save it
         y <- getChar
         return (x,y)
getLine :: IO String
getLine = do x <- getChar
             if x == '\n' then return [] else do xs <- getLine
                                                 return (x:xs)
{--}
